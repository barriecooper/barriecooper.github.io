{"name": "Graphs game", "version": "0.1", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Graphs game-0.1-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "3", "hidden": false}, {"type": "text", "content": "4"}, {"type": "lean", "content": "5", "hidden": false}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": false}, {"type": "text", "content": "8"}, {"type": "lean", "content": "9", "hidden": false}, {"type": "text", "content": "10"}, {"type": "lean", "content": "11", "hidden": false}, {"type": "text", "content": "12"}, {"type": "lemma", "text": "13", "lean": "lemma compatability {G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints :=\n", "sideBar": true, "firstProofLineNumber": 52, "lastProofLineNumber": 55, "textBefore": "import data.sym2 -- allows us to use unordered pairs\nopen function -- allows us to use key results about functions\n\n/-\nWe begin by defining a graph as a triple:\n- vertices;\n- edges;\n- and an endpoint map taking each edge to the unordered pair of its endpoints.\n-/\n\nstructure graph :=\n  (vertices : Type)\n  (edges : Type)\n  (endpoints : edges \u2192 sym2 vertices)\n\n/-\nNow we can define adjacency.\n-/\n\ndef are_adjacent (G : graph) (a b : G.vertices) : Prop := \u2203 e : G.edges, G.endpoints(e) = \u27e6(a,b)\u27e7\n\n/-\nWe now define a morphism of graphs to be a triple:\n- a map on vertices;\n- a map on edges;\n- and a compatability condition between the two maps.\n-/\n\nstructure morphism (G : graph) (H : graph) :=\n  (vertex_map : G.vertices \u2192 H.vertices)\n  (edge_map : G.edges \u2192 H.edges)\n  (compatability : H.endpoints \u2218 edge_map = sym2.map vertex_map \u2218 G.endpoints)\n\n/-\nWe want a convenient infix notation for a morphism.\n-/\n\ninfix `\u21a6` :50 := morphism\n\n/-\nWe want to define composition of morphisms, so your first task is to prove that the\ncompatability condition needed holds when we do the `obvious' thing ... you will want \nto use the result sym2.map_comp.\n-/\n\n/- Lemma :\nFor all graphs $G$, $H$ and $K$ and for all morphisms $\u03b1 : G \u2192 H$ and $\u03b2 : H \u2192 K$, we have\n$\u03b5_K \u2218 \u03b2_e \u2218 \u03b1_e = sym2 (\u03b2_v \u2218 \u03b1_v) \u2218 \u03b5_G$.\n-/\nlemma compatability {G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints :=\nbegin\n", "proof": "  calc K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = (sym2.map \u03b2.vertex_map \u2218 H.endpoints) \u2218 \u03b1.edge_map : by rw \u2190 \u03b2.compatability\n                                         ... = sym2.map \u03b2.vertex_map \u2218 (sym2.map \u03b1.vertex_map \u2218 G.endpoints) : by rw \u2190 \u03b1.compatability\n                                         ... = (sym2.map \u03b2.vertex_map \u2218 sym2.map \u03b1.vertex_map) \u2218 G.endpoints : by refl\n                                         ... = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints : by rw \u2190 sym2.map_comp,", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 51, "name": "compatability", "statement": "{G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "14", "hidden": false}, {"type": "text", "content": "15"}, {"type": "lean", "content": "16", "hidden": false}, {"type": "text", "content": "17"}, {"type": "lean", "content": "18", "hidden": false}, {"type": "text", "content": "19"}, {"type": "lemma", "text": "20", "lean": "lemma mor_assoc {G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1 :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 38, "textBefore": "import data.sym2 -- allows us to use unordered pairs\nopen function -- allows us to use key results about functions\n\nstructure graph :=\n  (vertices : Type)\n  (edges : Type)\n  (endpoints : edges \u2192 sym2 vertices)\n\nstructure morphism (G : graph) (H : graph) :=\n  (vertex_map : G.vertices \u2192 H.vertices)\n  (edge_map : G.edges \u2192 H.edges)\n  (compatability : H.endpoints \u2218 edge_map = sym2.map vertex_map \u2218 G.endpoints)\n\ninfix `\u21a6` :50 := morphism\n/-\nNow that we know the compatability condition holds, we can go ahead and \ndefine composition of morphisms.\n-/\n\ndef compose {G H K : graph} (\u03b2 : H \u21a6 K) (\u03b1 : G \u21a6 H) : G \u21a6 K :=\n  morphism.mk (\u03b2.vertex_map \u2218 \u03b1.vertex_map) (\u03b2.edge_map \u2218 \u03b1.edge_map) (by exact compatability \u03b1 \u03b2)\n\n/-\nWe want a convenient infix operator for composition of morphisms.\n-/\n\ninfix `\u229a`:80 := compose\n\n/-\nProving associativity of composition is now trivial ...\n-/\n/- Lemma :\nFor all morphisms $\u03b1 : G \u2192 H$, $\u03b2 : H \u2192 K$ and $\u03b3 : K \u2192 L$, we have\n$\u03b3 \u2218 (\u03b2 \u2218 \u03b1) = (\u03b3 \u2218 \u03b2) \u2218 \u03b1$.\n-/\nlemma mor_assoc {G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1 :=\nbegin\n", "proof": "  refl,", "textAfter": "\nend\n", "height": 1, "editorText": "sorry", "lineOffset": 37, "name": "mor_assoc", "statement": "{G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1"}]}]}], "texts": [["Graphs game", "# The Graphs Game, version 0.1\n## Barrie Cooper. \nThis game uses Lean to prove various results about graphs and is \nbased on the course MTH3022 Graphs, Networks and Algorithms at the \nUniversity of Exeter.\n", "Morphisms world", "import data.sym2 -- allows us to use unordered pairs\nopen function -- allows us to use key results about functions\n", "We begin by defining a graph as a triple:\n- vertices;\n- edges;\n- and an endpoint map taking each edge to the unordered pair of its endpoints.\n", "structure graph :=\n  (vertices : Type)\n  (edges : Type)\n  (endpoints : edges \u2192 sym2 vertices)\n", "Now we can define adjacency.\n", "def are_adjacent (G : graph) (a b : G.vertices) : Prop := \u2203 e : G.edges, G.endpoints(e) = \u27e6(a,b)\u27e7\n", "We now define a morphism of graphs to be a triple:\n- a map on vertices;\n- a map on edges;\n- and a compatability condition between the two maps.\n", "structure morphism (G : graph) (H : graph) :=\n  (vertex_map : G.vertices \u2192 H.vertices)\n  (edge_map : G.edges \u2192 H.edges)\n  (compatability : H.endpoints \u2218 edge_map = sym2.map vertex_map \u2218 G.endpoints)\n", "We want a convenient infix notation for a morphism.\n", "infix `\u21a6` :50 := morphism\n", "We want to define composition of morphisms, so your first task is to prove that the\ncompatability condition needed holds when we do the `obvious' thing ... you will want \nto use the result sym2.map_comp.\n", "For all graphs $G$, $H$ and $K$ and for all morphisms $\u03b1 : G \u2192 H$ and $\u03b2 : H \u2192 K$, we have\n$\u03b5_K \u2218 \u03b2_e \u2218 \u03b1_e = sym2 (\u03b2_v \u2218 \u03b1_v) \u2218 \u03b5_G$.\n", "import data.sym2 -- allows us to use unordered pairs\nopen function -- allows us to use key results about functions\nstructure graph :=\n  (vertices : Type)\n  (edges : Type)\n  (endpoints : edges \u2192 sym2 vertices)\nstructure morphism (G : graph) (H : graph) :=\n  (vertex_map : G.vertices \u2192 H.vertices)\n  (edge_map : G.edges \u2192 H.edges)\n  (compatability : H.endpoints \u2218 edge_map = sym2.map vertex_map \u2218 G.endpoints)\ninfix `\u21a6` :50 := morphism\n", "Now that we know the compatability condition holds, we can go ahead and \ndefine composition of morphisms.\n", "def compose {G H K : graph} (\u03b2 : H \u21a6 K) (\u03b1 : G \u21a6 H) : G \u21a6 K :=\n  morphism.mk (\u03b2.vertex_map \u2218 \u03b1.vertex_map) (\u03b2.edge_map \u2218 \u03b1.edge_map) (by exact compatability \u03b1 \u03b2)\n", "We want a convenient infix operator for composition of morphisms.\n", "infix `\u229a`:80 := compose\n", "Proving associativity of composition is now trivial ...\n", "For all morphisms $\u03b1 : G \u2192 H$, $\u03b2 : H \u2192 K$ and $\u03b3 : K \u2192 L$, we have\n$\u03b3 \u2218 (\u03b2 \u2218 \u03b1) = (\u03b3 \u2218 \u03b2) \u2218 \u03b1$.\n"]]}