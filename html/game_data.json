{"name": "Graphs game", "version": "0.1", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Graphs game-0.1-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "3", "hidden": false}, {"type": "text", "content": "4"}, {"type": "lean", "content": "5", "hidden": false}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": false}, {"type": "text", "content": "8"}, {"type": "lean", "content": "9", "hidden": false}, {"type": "text", "content": "10"}, {"type": "lean", "content": "11", "hidden": false}, {"type": "text", "content": "12"}, {"type": "lemma", "text": "13", "lean": "lemma compatability {G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints :=\n", "sideBar": true, "firstProofLineNumber": 51, "lastProofLineNumber": 54, "textBefore": "import data.sym2 -- allows us to use unordered pairs\n\n/-\nWe begin by defining a graph as a triple:\n- vertices;\n- edges;\n- and an endpoint map taking each edge to the unordered pair of its endpoints.\n-/\n\nstructure graph :=\n  (vertices : Type)\n  (edges : Type)\n  (endpoints : edges \u2192 sym2 vertices)\n\n/-\nNow we can define adjacency.\n-/\n\ndef are_adjacent (G : graph) (a b : G.vertices) : Prop := \u2203 e : G.edges, G.endpoints(e) = \u27e6(a,b)\u27e7\n\n/-\nWe now define a morphism of graphs to be a triple:\n- a map on vertices;\n- a map on edges;\n- and a compatability condition between the two maps.\n-/\n\nstructure morphism (G : graph) (H : graph) :=\n  (vertex_map : G.vertices \u2192 H.vertices)\n  (edge_map : G.edges \u2192 H.edges)\n  (compatability : H.endpoints \u2218 edge_map = sym2.map vertex_map \u2218 G.endpoints)\n\n/-\nWe want a convenient infix notation for a morphism.\n-/\n\ninfix `\u21a6` :50 := morphism\n\n/-\nWe want to define composition of morphisms, so your first task is to prove that the\ncompatability condition needed holds when we do the `obvious' thing ... you will want \nto use the result sym2.map_comp.\n-/\n\n/- Lemma :\nFor all graphs $G$, $H$ and $K$ and for all morphisms $\u03b1 : G \u2192 H$ and $\u03b2 : H \u2192 K$, we have\n$\u03b5_K \u2218 \u03b2_e \u2218 \u03b1_e = sym2 (\u03b2_v \u2218 \u03b1_v) \u2218 \u03b5_G$.\n-/\nlemma compatability {G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints :=\nbegin\n", "proof": "  calc K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = (sym2.map \u03b2.vertex_map \u2218 H.endpoints) \u2218 \u03b1.edge_map : by rw \u2190 \u03b2.compatability\n                                         ... = sym2.map \u03b2.vertex_map \u2218 (sym2.map \u03b1.vertex_map \u2218 G.endpoints) : by rw \u2190 \u03b1.compatability\n                                         ... = (sym2.map \u03b2.vertex_map \u2218 sym2.map \u03b1.vertex_map) \u2218 G.endpoints : by refl\n                                         ... = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints : by rw \u2190 sym2.map_comp,", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 50, "name": "compatability", "statement": "{G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "14", "hidden": false}, {"type": "text", "content": "15"}, {"type": "lean", "content": "16", "hidden": false}, {"type": "text", "content": "17"}, {"type": "lean", "content": "18", "hidden": false}, {"type": "text", "content": "19"}, {"type": "lemma", "text": "20", "lean": "lemma mor_assoc {G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1 :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 26, "textBefore": "import graphs.definitions\n\n/-\nNow that we know the compatability condition holds, we can go ahead and \ndefine composition of morphisms.\n-/\n\ndef compose {G H K : graph} (\u03b2 : H \u21a6 K) (\u03b1 : G \u21a6 H) : G \u21a6 K :=\n  morphism.mk (\u03b2.vertex_map \u2218 \u03b1.vertex_map) (\u03b2.edge_map \u2218 \u03b1.edge_map) (by exact compatability \u03b1 \u03b2)\n\n/-\nWe want a convenient infix operator for composition of morphisms.\n-/\n\ninfix `\u229a`:80 := compose\n\n/-\nProving associativity of composition is now trivial ...\n-/\n/- Lemma :\nFor all morphisms $\u03b1 : G \u2192 H$, $\u03b2 : H \u2192 K$ and $\u03b3 : K \u2192 L$, we have\n$\u03b3 \u2218 (\u03b2 \u2218 \u03b1) = (\u03b3 \u2218 \u03b2) \u2218 \u03b1$.\n-/\nlemma mor_assoc {G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1 :=\nbegin\n", "proof": "  refl,", "textAfter": "\nend\n", "height": 1, "editorText": "sorry", "lineOffset": 25, "name": "mor_assoc", "statement": "{G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1"}]}, {"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "21", "hidden": false}, {"type": "text", "content": "22"}, {"type": "lean", "content": "23", "hidden": false}, {"type": "text", "content": "24"}, {"type": "lean", "content": "25", "hidden": false}, {"type": "text", "content": "26"}, {"type": "lean", "content": "27", "hidden": false}, {"type": "text", "content": "28"}, {"type": "lean", "content": "29", "hidden": false}, {"type": "text", "content": "30"}, {"type": "lean", "content": "31", "hidden": false}, {"type": "text", "content": "32"}, {"type": "lean", "content": "33", "hidden": false}, {"type": "text", "content": "34"}, {"type": "lean", "content": "35", "hidden": false}]}]}], "texts": [["Graphs game", "# The Graphs Game, version 0.1\n## Barrie Cooper. \nThis game uses Lean to prove various results about graphs and is \nbased on the course MTH3022 Graphs, Networks and Algorithms at the \nUniversity of Exeter.\n", "Morphisms world", "import data.sym2 -- allows us to use unordered pairs\n", "We begin by defining a graph as a triple:\n- vertices;\n- edges;\n- and an endpoint map taking each edge to the unordered pair of its endpoints.\n", "structure graph :=\n  (vertices : Type)\n  (edges : Type)\n  (endpoints : edges \u2192 sym2 vertices)\n", "Now we can define adjacency.\n", "def are_adjacent (G : graph) (a b : G.vertices) : Prop := \u2203 e : G.edges, G.endpoints(e) = \u27e6(a,b)\u27e7\n", "We now define a morphism of graphs to be a triple:\n- a map on vertices;\n- a map on edges;\n- and a compatability condition between the two maps.\n", "structure morphism (G : graph) (H : graph) :=\n  (vertex_map : G.vertices \u2192 H.vertices)\n  (edge_map : G.edges \u2192 H.edges)\n  (compatability : H.endpoints \u2218 edge_map = sym2.map vertex_map \u2218 G.endpoints)\n", "We want a convenient infix notation for a morphism.\n", "infix `\u21a6` :50 := morphism\n", "We want to define composition of morphisms, so your first task is to prove that the\ncompatability condition needed holds when we do the `obvious' thing ... you will want \nto use the result sym2.map_comp.\n", "For all graphs $G$, $H$ and $K$ and for all morphisms $\u03b1 : G \u2192 H$ and $\u03b2 : H \u2192 K$, we have\n$\u03b5_K \u2218 \u03b2_e \u2218 \u03b1_e = sym2 (\u03b2_v \u2218 \u03b1_v) \u2218 \u03b5_G$.\n", "import graphs.definitions\n", "Now that we know the compatability condition holds, we can go ahead and \ndefine composition of morphisms.\n", "def compose {G H K : graph} (\u03b2 : H \u21a6 K) (\u03b1 : G \u21a6 H) : G \u21a6 K :=\n  morphism.mk (\u03b2.vertex_map \u2218 \u03b1.vertex_map) (\u03b2.edge_map \u2218 \u03b1.edge_map) (by exact compatability \u03b1 \u03b2)\n", "We want a convenient infix operator for composition of morphisms.\n", "infix `\u229a`:80 := compose\n", "Proving associativity of composition is now trivial ...\n", "For all morphisms $\u03b1 : G \u2192 H$, $\u03b2 : H \u2192 K$ and $\u03b3 : K \u2192 L$, we have\n$\u03b3 \u2218 (\u03b2 \u2218 \u03b1) = (\u03b3 \u2218 \u03b2) \u2218 \u03b1$.\n", "import graphs.composition\nopen function -- allows us to use key results about functions\n", "We want to define the identity morphism, but that requires a compatability proof.\n", "theorem id_compatability (G : graph) : G.endpoints \u2218 id = sym2.map id \u2218 G.endpoints :=\nbegin\n  rw sym2.map_id,\n  refl,\nend\n", "Now we can define the identity morphism.\n", "def \ud835\udd40 (G : graph) : G \u21a6 G :=\n  morphism.mk (id) (id) (by exact id_compatability G)\n", "Next we turn our attention to defining an isomorphism.\n", "def isomorphism {G H : graph} (\u03b1 : G \u21a6 H) : Prop :=\n  \u2203 \u03b2 : H \u21a6 G, \u03b1 \u229a \u03b2 = \ud835\udd40 H \u2227 \u03b2 \u229a \u03b1 = \ud835\udd40 G\n", "This is a sanity check: proving that the identity is an isomorphism.\n", "theorem id_is_iso (G : graph) : isomorphism (\ud835\udd40 G) :=\nbegin\n  use \ud835\udd40 G,\n  split,\n  refl,\n  refl,\nend\n", "Proving equality on structures is a pain, so we should prove an extensionality\ntheorem.  Basically, it suffices for the respective vertex maps and edge maps to \nbe equal.\n", "theorem mor_ext {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hv : \u03b1.vertex_map = \u03b2.vertex_map) (he : \u03b1.edge_map = \u03b2.edge_map) : \u03b1 = \u03b2 :=\nbegin\n  cases \u03b1,\n  cases \u03b2,\n  rw morphism.mk.inj_eq,\n  exact \u27e8hv, he\u27e9,\nend\n", "The next two are helpful so that we don't have to keep repeating silly proofs.\nBasically, we show that equal morphisms have equal vertex maps and edge maps.\n", "theorem eq_mor_eq_vmap {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.vertex_map = \u03b2.vertex_map :=\nbegin\n  cases \u03b1,\n  cases \u03b2,\n  rw morphism.mk.inj_eq at hyp,\n  exact hyp.1,\nend\ntheorem eq_mor_eq_emap {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.edge_map = \u03b2.edge_map :=\nbegin\n  cases \u03b1,\n  cases \u03b2,\n  rw morphism.mk.inj_eq at hyp,\n  exact hyp.2,\nend\n", "Our final two results are proving that a morphism is an isomorphism if and\nonly if the vertex map and edge map are both bijective.  Of course, we are\nleaning very heavily on the corresponding results for functions.\n", "theorem iso.bij {G H : graph} (\u03b1 : G \u21a6 H) (hyp : isomorphism \u03b1) : bijective \u03b1.vertex_map \u2227 bijective \u03b1.edge_map :=\nbegin\n  cases hyp with \u03b2 h\u03b2,\n  cases h\u03b2 with h\u2081 h\u2082,\n  split,\n  split,\n  have h\u2083 : left_inverse \u03b2.vertex_map \u03b1.vertex_map,\n  {\n    intro x,\n    calc \u03b2.vertex_map (\u03b1.vertex_map x) = (\u03b2 \u229a \u03b1).vertex_map x : by refl\n                                   ... = (\ud835\udd40 G).vertex_map x : by rw eq_mor_eq_vmap (\u03b2 \u229a \u03b1) (\ud835\udd40 G) (h\u2082)\n                                   ... = x : by refl,\n  },\n  apply left_inverse.injective h\u2083,\n  have h\u2083 : right_inverse \u03b2.vertex_map \u03b1.vertex_map,\n  {\n    intro x,\n    calc \u03b1.vertex_map (\u03b2.vertex_map x) = (\u03b1 \u229a \u03b2).vertex_map x : by refl\n                                   ... = (\ud835\udd40 H).vertex_map x : by rw eq_mor_eq_vmap (\u03b1 \u229a \u03b2) (\ud835\udd40 H) (h\u2081)\n                                   ... = x : by refl,\n  },\n  apply right_inverse.surjective h\u2083,\n  split,\n  have h\u2083 : left_inverse \u03b2.edge_map \u03b1.edge_map,\n  {\n    intro x,\n    calc \u03b2.edge_map (\u03b1.edge_map x) = (\u03b2 \u229a \u03b1).edge_map x : by refl\n                                   ... = (\ud835\udd40 G).edge_map x : by rw eq_mor_eq_emap (\u03b2 \u229a \u03b1) (\ud835\udd40 G) (h\u2082)\n                                   ... = x : by refl,\n  },\n  apply left_inverse.injective h\u2083,\n  have h\u2083 : right_inverse \u03b2.edge_map \u03b1.edge_map,\n  {\n    intro x,\n    calc \u03b1.edge_map (\u03b2.edge_map x) = (\u03b1 \u229a \u03b2).edge_map x : by refl\n                                   ... = (\ud835\udd40 H).edge_map x : by rw eq_mor_eq_emap (\u03b1 \u229a \u03b2) (\ud835\udd40 H) (h\u2081)\n                                   ... = x : by refl,\n  },\n  apply right_inverse.surjective h\u2083,\nend\ntheorem bij.iso {G H : graph} (\u03b1 : G \u21a6 H) (hv : bijective \u03b1.vertex_map) (he : bijective \u03b1.edge_map) : isomorphism \u03b1 :=\nbegin\n  let \u03c6 := \u03b1.vertex_map,\n  let \u03c8 := \u03b1.edge_map,\n  rw bijective_iff_has_inverse at hv,\n  cases hv with \u03c6' h\u03c6',\n  rw bijective_iff_has_inverse at he,\n  cases he with \u03c8' h\u03c8',\n  have comp' : G.endpoints \u2218 \u03c8' = sym2.map \u03c6' \u2218 H.endpoints,\n  {\n    calc G.endpoints \u2218 \u03c8' = id \u2218 G.endpoints \u2218 \u03c8' : by refl\n                      ... = sym2.map id \u2218 G.endpoints \u2218 \u03c8' : by rw sym2.map_id\n                      ... = sym2.map (\u03c6' \u2218 \u03c6) \u2218 G.endpoints \u2218 \u03c8' : by rw left_inverse.id h\u03c6'.1\n                      ... = sym2.map \u03c6' \u2218 sym2.map \u03c6 \u2218 G.endpoints \u2218 \u03c8' : by rw sym2.map_comp\n                      ... = sym2.map \u03c6' \u2218 (H.endpoints \u2218 \u03c8) \u2218 \u03c8' : by rw \u03b1.compatability\n                      ... = sym2.map \u03c6' \u2218 H.endpoints \u2218 (\u03c8 \u2218 \u03c8') : by refl\n                      ... = sym2.map \u03c6' \u2218 H.endpoints \u2218 id : by rw right_inverse.id h\u03c8'.2\n                      ... = sym2.map \u03c6' \u2218 H.endpoints : by refl,\n  },\n  let \u03b2 := morphism.mk (\u03c6') (\u03c8') (comp'),\n  use \u03b2,\n  split,\n  {\n    apply mor_ext,\n    {\n      calc (\u03b1 \u229a \u03b2).vertex_map = \u03b1.vertex_map \u2218 \u03b2.vertex_map : by refl\n                          ... = \u03c6 \u2218 \u03c6' : by refl\n                          ... = id : by exact left_inverse.id h\u03c6'.2\n                          ... = (\ud835\udd40 H).vertex_map : by refl,\n    },\n    {\n      calc (\u03b1 \u229a \u03b2).edge_map = \u03b1.edge_map \u2218 \u03b2.edge_map : by refl\n                          ... = \u03c8 \u2218 \u03c8' : by refl\n                          ... = id : by exact left_inverse.id h\u03c8'.2\n                          ... = (\ud835\udd40 H).edge_map : by refl,\n    },\n  },\n  {\n    apply mor_ext,\n    {\n      calc (\u03b2 \u229a \u03b1).vertex_map = \u03b2.vertex_map \u2218 \u03b1.vertex_map : by refl\n                          ... = \u03c6' \u2218 \u03c6 : by refl\n                          ... = id : by exact left_inverse.id h\u03c6'.1\n                          ... = (\ud835\udd40 G).vertex_map : by refl,\n    },\n    {\n      calc (\u03b2 \u229a \u03b1).edge_map = \u03b2.edge_map \u2218 \u03b1.edge_map : by refl\n                          ... = \u03c8' \u2218 \u03c8 : by refl\n                          ... = id : by exact left_inverse.id h\u03c8'.1\n                          ... = (\ud835\udd40 G).edge_map : by refl,\n    },\n  },\nend"]]}